<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>json-c: linkhash.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">json-c<span id="projectnumber">&#160;0.18.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">linkhash.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Internal methods for working with json_type_object objects. Although this is exposed by the <a class="el" href="json__object_8h.html#ad59d615fe79a882586991c8183fa4264">json_object_get_object()</a> function and within the <a class="el" href="structjson__object__iter.html">json_object_iter</a> type, it is not recommended for direct use.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:lh_5Fentry" id="r_lh_5Fentry"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlh__entry.html">lh_entry</a></td></tr>
<tr class="memitem:lh_5Ftable" id="r_lh_5Ftable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlh__table.html">lh_table</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a032f1bd115df254dda325437203ce5fb" id="r_a032f1bd115df254dda325437203ce5fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a032f1bd115df254dda325437203ce5fb">LH_PRIME</a>&#160;&#160;&#160;0x9e370001UL</td></tr>
<tr class="memitem:a66b61772c29d85eb52b697e0b0dc0aaf" id="r_a66b61772c29d85eb52b697e0b0dc0aaf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66b61772c29d85eb52b697e0b0dc0aaf">LH_LOAD_FACTOR</a>&#160;&#160;&#160;0.66</td></tr>
<tr class="memitem:a93fad7f8ae44575dc89c9567859972d2" id="r_a93fad7f8ae44575dc89c9567859972d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93fad7f8ae44575dc89c9567859972d2">LH_EMPTY</a>&#160;&#160;&#160;(void *)-1</td></tr>
<tr class="memitem:ac69428f2de0a6fb080b6fb373d506aa7" id="r_ac69428f2de0a6fb080b6fb373d506aa7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac69428f2de0a6fb080b6fb373d506aa7">LH_FREED</a>&#160;&#160;&#160;(void *)-2</td></tr>
<tr class="memitem:ac32e80138c5be6dd9b0483a9cbcc8799" id="r_ac32e80138c5be6dd9b0483a9cbcc8799"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac32e80138c5be6dd9b0483a9cbcc8799">JSON_C_STR_HASH_DFLT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memitem:a62316f34fd42941b97a8e9a6b6e68faa" id="r_a62316f34fd42941b97a8e9a6b6e68faa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62316f34fd42941b97a8e9a6b6e68faa">JSON_C_STR_HASH_PERLLIKE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memitem:ad7dd67da915065dce2c6f44cb03e2d82" id="r_ad7dd67da915065dce2c6f44cb03e2d82"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7dd67da915065dce2c6f44cb03e2d82">lh_foreach</a>(table,  entry)</td></tr>
<tr class="memitem:abcbb0df08b4976d0649b826b6bacfca1" id="r_abcbb0df08b4976d0649b826b6bacfca1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcbb0df08b4976d0649b826b6bacfca1">lh_foreach_safe</a>(table,  entry,  tmp)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa8cf4b706dbd4b8ad4e481e4c8e294d6" id="r_aa8cf4b706dbd4b8ad4e481e4c8e294d6"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8cf4b706dbd4b8ad4e481e4c8e294d6">lh_entry_free_fn</a>(struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td></tr>
<tr class="memitem:a91b6ee7cf017c5681bd057423a0401ab" id="r_a91b6ee7cf017c5681bd057423a0401ab"><td class="memItemLeft" align="right" valign="top">typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91b6ee7cf017c5681bd057423a0401ab">lh_hash_fn</a>(const void *k)</td></tr>
<tr class="memitem:a04c1133c2f393b9b1be11e0a41a104b4" id="r_a04c1133c2f393b9b1be11e0a41a104b4"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04c1133c2f393b9b1be11e0a41a104b4">lh_equal_fn</a>(const void *k1, const void *k2)</td></tr>
<tr class="memitem:a766e90057496fc6712d6be0da180a21f" id="r_a766e90057496fc6712d6be0da180a21f"><td class="memItemLeft" align="right" valign="top">typedef struct lh_table&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a766e90057496fc6712d6be0da180a21f">lh_table</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac8e1d61af44d9c0824d8c7980385bcd3" id="r_ac8e1d61af44d9c0824d8c7980385bcd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8e1d61af44d9c0824d8c7980385bcd3">json_global_set_string_hash</a> (const int h)</td></tr>
<tr class="memitem:a3f1d754f41d1ff89c45a552472e3a671" id="r_a3f1d754f41d1ff89c45a552472e3a671"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f1d754f41d1ff89c45a552472e3a671">lh_table_new</a> (int size, <a class="el" href="#aa8cf4b706dbd4b8ad4e481e4c8e294d6">lh_entry_free_fn</a> *free_fn, <a class="el" href="#a91b6ee7cf017c5681bd057423a0401ab">lh_hash_fn</a> *hash_fn, <a class="el" href="#a04c1133c2f393b9b1be11e0a41a104b4">lh_equal_fn</a> *equal_fn)</td></tr>
<tr class="memitem:add631744a85cad9ffa0e37d86b8d2baa" id="r_add631744a85cad9ffa0e37d86b8d2baa"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add631744a85cad9ffa0e37d86b8d2baa">lh_kchar_table_new</a> (int size, <a class="el" href="#aa8cf4b706dbd4b8ad4e481e4c8e294d6">lh_entry_free_fn</a> *free_fn)</td></tr>
<tr class="memitem:a870ed3dfc78d586638f0cd62103b5f87" id="r_a870ed3dfc78d586638f0cd62103b5f87"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlh__table.html">lh_table</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a870ed3dfc78d586638f0cd62103b5f87">lh_kptr_table_new</a> (int size, <a class="el" href="#aa8cf4b706dbd4b8ad4e481e4c8e294d6">lh_entry_free_fn</a> *free_fn)</td></tr>
<tr class="memitem:a81653acf740cf8c9fe672e6cd16df0cf" id="r_a81653acf740cf8c9fe672e6cd16df0cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81653acf740cf8c9fe672e6cd16df0cf">lh_table_free</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t)</td></tr>
<tr class="memitem:a86c0cd547be1e2c2486a73bd58e1352c" id="r_a86c0cd547be1e2c2486a73bd58e1352c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86c0cd547be1e2c2486a73bd58e1352c">lh_table_insert</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, const void *k, const void *v)</td></tr>
<tr class="memitem:a4558a9347a422e03a15b0b7a29b82dc3" id="r_a4558a9347a422e03a15b0b7a29b82dc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4558a9347a422e03a15b0b7a29b82dc3">lh_table_insert_w_hash</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, const void *k, const void *v, const unsigned long h, const unsigned opts)</td></tr>
<tr class="memitem:af50f3232ebc21425baaebeb8416f530c" id="r_af50f3232ebc21425baaebeb8416f530c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af50f3232ebc21425baaebeb8416f530c">lh_table_lookup_entry</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, const void *k)</td></tr>
<tr class="memitem:a068fcae8ec29b6357ca721b6971e8cc6" id="r_a068fcae8ec29b6357ca721b6971e8cc6"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a068fcae8ec29b6357ca721b6971e8cc6">lh_table_lookup_entry_w_hash</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, const void *k, const unsigned long h)</td></tr>
<tr class="memitem:a81c270bb0dd9d5c8a3e7ae20bc4d67f3" id="r_a81c270bb0dd9d5c8a3e7ae20bc4d67f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="json__types_8h.html#a81f02022906fafc71eb9197049f07f73">json_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81c270bb0dd9d5c8a3e7ae20bc4d67f3">lh_table_lookup_ex</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, const void *k, void **v)</td></tr>
<tr class="memitem:ae5885a71c3457190fb1dc2d6e20dde3b" id="r_ae5885a71c3457190fb1dc2d6e20dde3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5885a71c3457190fb1dc2d6e20dde3b">lh_table_delete_entry</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td></tr>
<tr class="memitem:a2fed2c78f70d229edb2d00775ffe593c" id="r_a2fed2c78f70d229edb2d00775ffe593c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fed2c78f70d229edb2d00775ffe593c">lh_table_delete</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, const void *k)</td></tr>
<tr class="memitem:ac9ba631c91fe80fb905f04c7cd526f2b" id="r_ac9ba631c91fe80fb905f04c7cd526f2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9ba631c91fe80fb905f04c7cd526f2b">lh_table_length</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t)</td></tr>
<tr class="memitem:a30c8414e31aeee7669acc938116d933f" id="r_a30c8414e31aeee7669acc938116d933f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30c8414e31aeee7669acc938116d933f">lh_table_resize</a> (struct <a class="el" href="structlh__table.html">lh_table</a> *t, int new_size)</td></tr>
<tr class="memitem:a37bd2f8ccaea39278a13b6eaada657d7" id="r_a37bd2f8ccaea39278a13b6eaada657d7"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37bd2f8ccaea39278a13b6eaada657d7">lh_table_head</a> (const <a class="el" href="structlh__table.html">lh_table</a> *t)</td></tr>
<tr class="memitem:a33c74c884530d407d0b3baa365238fb4" id="r_a33c74c884530d407d0b3baa365238fb4"><td class="memItemLeft" align="right" valign="top">static unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33c74c884530d407d0b3baa365238fb4">lh_get_hash</a> (const struct <a class="el" href="structlh__table.html">lh_table</a> *t, const void *k)</td></tr>
<tr class="memitem:a1ccddba74d3be7588e11333eda1f20ac" id="r_a1ccddba74d3be7588e11333eda1f20ac"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ccddba74d3be7588e11333eda1f20ac">lh_entry_k</a> (const struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td></tr>
<tr class="memitem:a724c308f1c606271ea3deb01ed9e3cc9" id="r_a724c308f1c606271ea3deb01ed9e3cc9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a724c308f1c606271ea3deb01ed9e3cc9">lh_entry_k_is_constant</a> (const struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td></tr>
<tr class="memitem:abbbcaaaad12ca6bcaebe2cd1437f17a0" id="r_abbbcaaaad12ca6bcaebe2cd1437f17a0"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbbcaaaad12ca6bcaebe2cd1437f17a0">lh_entry_v</a> (const struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td></tr>
<tr class="memitem:ad94e87a8ef92ee6371e5314b7241e635" id="r_ad94e87a8ef92ee6371e5314b7241e635"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad94e87a8ef92ee6371e5314b7241e635">lh_entry_set_val</a> (struct <a class="el" href="structlh__entry.html">lh_entry</a> *e, void *newval)</td></tr>
<tr class="memitem:a3b14a53ba9926b219190105f14d751b0" id="r_a3b14a53ba9926b219190105f14d751b0"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b14a53ba9926b219190105f14d751b0">lh_entry_next</a> (const struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td></tr>
<tr class="memitem:a51bb82fec8a605cc219f11890e837ef1" id="r_a51bb82fec8a605cc219f11890e837ef1"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structlh__entry.html">lh_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51bb82fec8a605cc219f11890e837ef1">lh_entry_prev</a> (const struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Internal methods for working with json_type_object objects. Although this is exposed by the <a class="el" href="json__object_8h.html#ad59d615fe79a882586991c8183fa4264">json_object_get_object()</a> function and within the <a class="el" href="structjson__object__iter.html">json_object_iter</a> type, it is not recommended for direct use. </p>
</div><a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ac32e80138c5be6dd9b0483a9cbcc8799" name="ac32e80138c5be6dd9b0483a9cbcc8799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32e80138c5be6dd9b0483a9cbcc8799">&#9670;&#160;</a></span>JSON_C_STR_HASH_DFLT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define JSON_C_STR_HASH_DFLT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>default string hash function </p>

</div>
</div>
<a id="a62316f34fd42941b97a8e9a6b6e68faa" name="a62316f34fd42941b97a8e9a6b6e68faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62316f34fd42941b97a8e9a6b6e68faa">&#9670;&#160;</a></span>JSON_C_STR_HASH_PERLLIKE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define JSON_C_STR_HASH_PERLLIKE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>perl-like string hash function </p>

</div>
</div>
<a id="a93fad7f8ae44575dc89c9567859972d2" name="a93fad7f8ae44575dc89c9567859972d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fad7f8ae44575dc89c9567859972d2">&#9670;&#160;</a></span>LH_EMPTY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LH_EMPTY&#160;&#160;&#160;(void *)-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sentinel pointer value for empty slots </p>

</div>
</div>
<a id="ad7dd67da915065dce2c6f44cb03e2d82" name="ad7dd67da915065dce2c6f44cb03e2d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7dd67da915065dce2c6f44cb03e2d82">&#9670;&#160;</a></span>lh_foreach</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lh_foreach</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>table</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span> (entry = <a class="code hl_function" href="#a37bd2f8ccaea39278a13b6eaada657d7">lh_table_head</a>(table); entry; entry = <a class="code hl_function" href="#a3b14a53ba9926b219190105f14d751b0">lh_entry_next</a>(entry))</div>
<div class="ttc" id="alinkhash_8h_html_a37bd2f8ccaea39278a13b6eaada657d7"><div class="ttname"><a href="#a37bd2f8ccaea39278a13b6eaada657d7">lh_table_head</a></div><div class="ttdeci">static struct lh_entry * lh_table_head(const lh_table *t)</div><div class="ttdef"><b>Definition</b> linkhash.h:349</div></div>
<div class="ttc" id="alinkhash_8h_html_a3b14a53ba9926b219190105f14d751b0"><div class="ttname"><a href="#a3b14a53ba9926b219190105f14d751b0">lh_entry_next</a></div><div class="ttdeci">static struct lh_entry * lh_entry_next(const struct lh_entry *e)</div><div class="ttdef"><b>Definition</b> linkhash.h:427</div></div>
</div><!-- fragment --><p>Convenience list iterator. </p>

</div>
</div>
<a id="abcbb0df08b4976d0649b826b6bacfca1" name="abcbb0df08b4976d0649b826b6bacfca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbb0df08b4976d0649b826b6bacfca1">&#9670;&#160;</a></span>lh_foreach_safe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lh_foreach_safe</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>table</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>entry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>tmp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        <span class="keywordflow">for</span> (entry = <a class="code hl_function" href="#a37bd2f8ccaea39278a13b6eaada657d7">lh_table_head</a>(table); entry &amp;&amp; ((tmp = <a class="code hl_function" href="#a3b14a53ba9926b219190105f14d751b0">lh_entry_next</a>(entry)) || 1); entry = tmp)</div>
</div><!-- fragment --><p>lh_foreach_safe allows calling of deletion routine while iterating.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>a struct <a class="el" href="structlh__table.html">lh_table</a> * to iterate over </td></tr>
    <tr><td class="paramname">entry</td><td>a struct <a class="el" href="structlh__entry.html">lh_entry</a> * variable to hold each element </td></tr>
    <tr><td class="paramname">tmp</td><td>a struct <a class="el" href="structlh__entry.html">lh_entry</a> * variable to hold a temporary pointer to the next element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac69428f2de0a6fb080b6fb373d506aa7" name="ac69428f2de0a6fb080b6fb373d506aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69428f2de0a6fb080b6fb373d506aa7">&#9670;&#160;</a></span>LH_FREED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LH_FREED&#160;&#160;&#160;(void *)-2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sentinel pointer value for freed slots </p>

</div>
</div>
<a id="a66b61772c29d85eb52b697e0b0dc0aaf" name="a66b61772c29d85eb52b697e0b0dc0aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b61772c29d85eb52b697e0b0dc0aaf">&#9670;&#160;</a></span>LH_LOAD_FACTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LH_LOAD_FACTOR&#160;&#160;&#160;0.66</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The fraction of filled hash buckets until an insert will cause the table to be resized. This can range from just above 0 up to 1.0. </p>

</div>
</div>
<a id="a032f1bd115df254dda325437203ce5fb" name="a032f1bd115df254dda325437203ce5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032f1bd115df254dda325437203ce5fb">&#9670;&#160;</a></span>LH_PRIME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LH_PRIME&#160;&#160;&#160;0x9e370001UL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>golden prime used in hash functions </p>

</div>
</div>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="aa8cf4b706dbd4b8ad4e481e4c8e294d6" name="aa8cf4b706dbd4b8ad4e481e4c8e294d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cf4b706dbd4b8ad4e481e4c8e294d6">&#9670;&#160;</a></span>lh_entry_free_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void lh_entry_free_fn(struct <a class="el" href="structlh__entry.html">lh_entry</a> *e)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>callback function prototypes </p>

</div>
</div>
<a id="a04c1133c2f393b9b1be11e0a41a104b4" name="a04c1133c2f393b9b1be11e0a41a104b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c1133c2f393b9b1be11e0a41a104b4">&#9670;&#160;</a></span>lh_equal_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int lh_equal_fn(const void *k1, const void *k2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>callback function prototypes </p>

</div>
</div>
<a id="a91b6ee7cf017c5681bd057423a0401ab" name="a91b6ee7cf017c5681bd057423a0401ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b6ee7cf017c5681bd057423a0401ab">&#9670;&#160;</a></span>lh_hash_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long lh_hash_fn(const void *k)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>callback function prototypes </p>

</div>
</div>
<a id="a766e90057496fc6712d6be0da180a21f" name="a766e90057496fc6712d6be0da180a21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766e90057496fc6712d6be0da180a21f">&#9670;&#160;</a></span>lh_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct lh_table lh_table</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ac8e1d61af44d9c0824d8c7980385bcd3" name="ac8e1d61af44d9c0824d8c7980385bcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e1d61af44d9c0824d8c7980385bcd3">&#9670;&#160;</a></span>json_global_set_string_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int json_global_set_string_hash </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>h</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the hash function to be used for strings. Must be one of the JSON_C_STR_HASH_* values. </p><dl class="section return"><dt>Returns</dt><dd>0 - ok, -1 if parameter was invalid </dd></dl>

</div>
</div>
<a id="a1ccddba74d3be7588e11333eda1f20ac" name="a1ccddba74d3be7588e11333eda1f20ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccddba74d3be7588e11333eda1f20ac">&#9670;&#160;</a></span>lh_entry_k()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * lh_entry_k </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlh__entry.html">lh_entry</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a non-const version of <a class="el" href="structlh__entry.html#a79d9f1ef0dc444e17105aaeaf167e22c">lh_entry.k</a>.</p>
<p><a class="el" href="structlh__entry.html#a79d9f1ef0dc444e17105aaeaf167e22c">lh_entry.k</a> is const to indicate and help ensure that linkhash itself doesn't modify it, but callers are allowed to do what they want with it. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a724c308f1c606271ea3deb01ed9e3cc9">lh_entry_k_is_constant()</a> </dd></dl>

<p class="reference">References <a class="el" href="structlh__entry.html#a79d9f1ef0dc444e17105aaeaf167e22c">lh_entry::k</a>.</p>

</div>
</div>
<a id="a724c308f1c606271ea3deb01ed9e3cc9" name="a724c308f1c606271ea3deb01ed9e3cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724c308f1c606271ea3deb01ed9e3cc9">&#9670;&#160;</a></span>lh_entry_k_is_constant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int lh_entry_k_is_constant </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlh__entry.html">lh_entry</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns 1 if the key for the given entry is constant, and thus does not need to be freed when the <a class="el" href="structlh__entry.html">lh_entry</a> is freed. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4558a9347a422e03a15b0b7a29b82dc3">lh_table_insert_w_hash()</a> </dd></dl>

<p class="reference">References <a class="el" href="structlh__entry.html#a14f40cc124c32b03f81151ae7934d2e7">lh_entry::k_is_constant</a>.</p>

</div>
</div>
<a id="a3b14a53ba9926b219190105f14d751b0" name="a3b14a53ba9926b219190105f14d751b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b14a53ba9926b219190105f14d751b0">&#9670;&#160;</a></span>lh_entry_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlh__entry.html">lh_entry</a> * lh_entry_next </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlh__entry.html">lh_entry</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the next element, or NULL if there is no next element. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a37bd2f8ccaea39278a13b6eaada657d7">lh_table_head()</a> </dd>
<dd>
<a class="el" href="#a51bb82fec8a605cc219f11890e837ef1">lh_entry_prev()</a> </dd></dl>

<p class="reference">References <a class="el" href="structlh__entry.html#a7c40c46e72d9a0ba071a8d49d535bc67">lh_entry::next</a>.</p>

</div>
</div>
<a id="a51bb82fec8a605cc219f11890e837ef1" name="a51bb82fec8a605cc219f11890e837ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bb82fec8a605cc219f11890e837ef1">&#9670;&#160;</a></span>lh_entry_prev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlh__entry.html">lh_entry</a> * lh_entry_prev </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlh__entry.html">lh_entry</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the previous element, or NULL if there is no previous element. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a37bd2f8ccaea39278a13b6eaada657d7">lh_table_head()</a> </dd>
<dd>
<a class="el" href="#a3b14a53ba9926b219190105f14d751b0">lh_entry_next()</a> </dd></dl>

<p class="reference">References <a class="el" href="structlh__entry.html#a6fb9c3de01fb5af67d8d429921cc6a3b">lh_entry::prev</a>.</p>

</div>
</div>
<a id="ad94e87a8ef92ee6371e5314b7241e635" name="ad94e87a8ef92ee6371e5314b7241e635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94e87a8ef92ee6371e5314b7241e635">&#9670;&#160;</a></span>lh_entry_set_val()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lh_entry_set_val </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__entry.html">lh_entry</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>newval</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the value for an entry. The caller is responsible for freeing the previous value. </p>

<p class="reference">References <a class="el" href="structlh__entry.html#a1b676732ab2ad3eeaedf6ec60a6a0835">lh_entry::v</a>.</p>

</div>
</div>
<a id="abbbcaaaad12ca6bcaebe2cd1437f17a0" name="abbbcaaaad12ca6bcaebe2cd1437f17a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbcaaaad12ca6bcaebe2cd1437f17a0">&#9670;&#160;</a></span>lh_entry_v()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * lh_entry_v </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlh__entry.html">lh_entry</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a non-const version of <a class="el" href="structlh__entry.html#a1b676732ab2ad3eeaedf6ec60a6a0835">lh_entry.v</a>.</p>
<p>v is const to indicate and help ensure that linkhash itself doesn't modify it, but callers are allowed to do what they want with it. </p>

<p class="reference">References <a class="el" href="structlh__entry.html#a1b676732ab2ad3eeaedf6ec60a6a0835">lh_entry::v</a>.</p>

</div>
</div>
<a id="a33c74c884530d407d0b3baa365238fb4" name="a33c74c884530d407d0b3baa365238fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c74c884530d407d0b3baa365238fb4">&#9670;&#160;</a></span>lh_get_hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long lh_get_hash </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlh__table.html">lh_table</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the hash of a key for a given table.</p>
<p>This is an extension to support functions that need to calculate the hash several times and allows them to do it just once and then pass in the hash to all utility functions. Depending on use case, this can be a considerable performance improvement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table (used to obtain hash function) </td></tr>
    <tr><td class="paramname">k</td><td>a pointer to the key to lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the key's hash </dd></dl>

<p class="reference">References <a class="el" href="structlh__table.html#a1488d1a4a320b1a9bb2f441859544be1">lh_table::hash_fn</a>, and <a class="el" href="structlh__entry.html#a79d9f1ef0dc444e17105aaeaf167e22c">lh_entry::k</a>.</p>

</div>
</div>
<a id="add631744a85cad9ffa0e37d86b8d2baa" name="add631744a85cad9ffa0e37d86b8d2baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add631744a85cad9ffa0e37d86b8d2baa">&#9670;&#160;</a></span>lh_kchar_table_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlh__table.html">lh_table</a> * lh_kchar_table_new </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa8cf4b706dbd4b8ad4e481e4c8e294d6">lh_entry_free_fn</a> *</td>          <td class="paramname"><span class="paramname"><em>free_fn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function to create a new linkhash table with char keys.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>initial table size. </td></tr>
    <tr><td class="paramname">free_fn</td><td>callback function used to free memory for entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the new linkhash table is returned. On error, a null pointer is returned. </dd></dl>

</div>
</div>
<a id="a870ed3dfc78d586638f0cd62103b5f87" name="a870ed3dfc78d586638f0cd62103b5f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870ed3dfc78d586638f0cd62103b5f87">&#9670;&#160;</a></span>lh_kptr_table_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlh__table.html">lh_table</a> * lh_kptr_table_new </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa8cf4b706dbd4b8ad4e481e4c8e294d6">lh_entry_free_fn</a> *</td>          <td class="paramname"><span class="paramname"><em>free_fn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function to create a new linkhash table with ptr keys.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>initial table size. </td></tr>
    <tr><td class="paramname">free_fn</td><td>callback function used to free memory for entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the new linkhash table is returned. On error, a null pointer is returned. </dd></dl>

</div>
</div>
<a id="a2fed2c78f70d229edb2d00775ffe593c" name="a2fed2c78f70d229edb2d00775ffe593c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fed2c78f70d229edb2d00775ffe593c">&#9670;&#160;</a></span>lh_table_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int lh_table_delete </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete a record from the table.</p>
<p>If a callback free function is provided then it is called for the for the item being deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table to delete from. </td></tr>
    <tr><td class="paramname">k</td><td>a pointer to the key to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the item was deleted. </dd>
<dd>
-1 if it was not found. </dd></dl>

</div>
</div>
<a id="ae5885a71c3457190fb1dc2d6e20dde3b" name="ae5885a71c3457190fb1dc2d6e20dde3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5885a71c3457190fb1dc2d6e20dde3b">&#9670;&#160;</a></span>lh_table_delete_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int lh_table_delete_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlh__entry.html">lh_entry</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete a record from the table.</p>
<p>If a callback free function is provided then it is called for the for the item being deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table to delete from. </td></tr>
    <tr><td class="paramname">e</td><td>a pointer to the entry to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the item was deleted. </dd>
<dd>
-1 if it was not found. </dd></dl>

</div>
</div>
<a id="a81653acf740cf8c9fe672e6cd16df0cf" name="a81653acf740cf8c9fe672e6cd16df0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81653acf740cf8c9fe672e6cd16df0cf">&#9670;&#160;</a></span>lh_table_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lh_table_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free a linkhash table.</p>
<p>If a <a class="el" href="#aa8cf4b706dbd4b8ad4e481e4c8e294d6">lh_entry_free_fn</a> callback free function was provided then it is called for all entries in the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>table to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37bd2f8ccaea39278a13b6eaada657d7" name="a37bd2f8ccaea39278a13b6eaada657d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bd2f8ccaea39278a13b6eaada657d7">&#9670;&#160;</a></span>lh_table_head()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlh__entry.html">lh_entry</a> * lh_table_head </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlh__table.html">lh_table</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the first entry in the <a class="el" href="structlh__table.html">lh_table</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3b14a53ba9926b219190105f14d751b0">lh_entry_next()</a> </dd></dl>

<p class="reference">References <a class="el" href="structlh__table.html#aa7d986a3b12a9fa47e349713794c30fb">lh_table::head</a>.</p>

</div>
</div>
<a id="a86c0cd547be1e2c2486a73bd58e1352c" name="a86c0cd547be1e2c2486a73bd58e1352c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c0cd547be1e2c2486a73bd58e1352c">&#9670;&#160;</a></span>lh_table_insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int lh_table_insert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert a record into the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table to insert into. </td></tr>
    <tr><td class="paramname">k</td><td>a pointer to the key to insert. </td></tr>
    <tr><td class="paramname">v</td><td>a pointer to the value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, <code>0</code> is returned. On error, a negative value is returned. </dd></dl>

</div>
</div>
<a id="a4558a9347a422e03a15b0b7a29b82dc3" name="a4558a9347a422e03a15b0b7a29b82dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4558a9347a422e03a15b0b7a29b82dc3">&#9670;&#160;</a></span>lh_table_insert_w_hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int lh_table_insert_w_hash </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned</td>          <td class="paramname"><span class="paramname"><em>opts</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert a record into the table using a precalculated key hash.</p>
<p>The hash h, which should be calculated with <a class="el" href="#a33c74c884530d407d0b3baa365238fb4">lh_get_hash()</a> on k, is provided by the caller, to allow for optimization when multiple operations with the same key are known to be needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table to insert into. </td></tr>
    <tr><td class="paramname">k</td><td>a pointer to the key to insert. </td></tr>
    <tr><td class="paramname">v</td><td>a pointer to the value to insert. </td></tr>
    <tr><td class="paramname">h</td><td>hash value of the key to insert </td></tr>
    <tr><td class="paramname">opts</td><td>if set to JSON_C_OBJECT_ADD_CONSTANT_KEY, sets <a class="el" href="structlh__entry.html#a14f40cc124c32b03f81151ae7934d2e7">lh_entry.k_is_constant</a> so t's free function knows to avoid freeing the key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9ba631c91fe80fb905f04c7cd526f2b" name="ac9ba631c91fe80fb905f04c7cd526f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ba631c91fe80fb905f04c7cd526f2b">&#9670;&#160;</a></span>lh_table_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int lh_table_length </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of entries in the table. </p>

</div>
</div>
<a id="af50f3232ebc21425baaebeb8416f530c" name="af50f3232ebc21425baaebeb8416f530c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50f3232ebc21425baaebeb8416f530c">&#9670;&#160;</a></span>lh_table_lookup_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlh__entry.html">lh_entry</a> * lh_table_lookup_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lookup a record in the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table to lookup </td></tr>
    <tr><td class="paramname">k</td><td>a pointer to the key to lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the record structure of the value or NULL if it does not exist. </dd></dl>

</div>
</div>
<a id="a068fcae8ec29b6357ca721b6971e8cc6" name="a068fcae8ec29b6357ca721b6971e8cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068fcae8ec29b6357ca721b6971e8cc6">&#9670;&#160;</a></span>lh_table_lookup_entry_w_hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlh__entry.html">lh_entry</a> * lh_table_lookup_entry_w_hash </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long</td>          <td class="paramname"><span class="paramname"><em>h</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lookup a record in the table using a precalculated key hash.</p>
<p>The hash h, which should be calculated with <a class="el" href="#a33c74c884530d407d0b3baa365238fb4">lh_get_hash()</a> on k, is provided by the caller, to allow for optimization when multiple operations with the same key are known to be needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table to lookup </td></tr>
    <tr><td class="paramname">k</td><td>a pointer to the key to lookup </td></tr>
    <tr><td class="paramname">h</td><td>hash value of the key to lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the record structure of the value or NULL if it does not exist. </dd></dl>

</div>
</div>
<a id="a81c270bb0dd9d5c8a3e7ae20bc4d67f3" name="a81c270bb0dd9d5c8a3e7ae20bc4d67f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c270bb0dd9d5c8a3e7ae20bc4d67f3">&#9670;&#160;</a></span>lh_table_lookup_ex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json__types_8h.html#a81f02022906fafc71eb9197049f07f73">json_bool</a> lh_table_lookup_ex </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lookup a record in the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the table to lookup </td></tr>
    <tr><td class="paramname">k</td><td>a pointer to the key to lookup </td></tr>
    <tr><td class="paramname">v</td><td>a pointer to a where to store the found value (set to NULL if it doesn't exist). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the key was found </dd></dl>

</div>
</div>
<a id="a3f1d754f41d1ff89c45a552472e3a671" name="a3f1d754f41d1ff89c45a552472e3a671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1d754f41d1ff89c45a552472e3a671">&#9670;&#160;</a></span>lh_table_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlh__table.html">lh_table</a> * lh_table_new </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa8cf4b706dbd4b8ad4e481e4c8e294d6">lh_entry_free_fn</a> *</td>          <td class="paramname"><span class="paramname"><em>free_fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a91b6ee7cf017c5681bd057423a0401ab">lh_hash_fn</a> *</td>          <td class="paramname"><span class="paramname"><em>hash_fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a04c1133c2f393b9b1be11e0a41a104b4">lh_equal_fn</a> *</td>          <td class="paramname"><span class="paramname"><em>equal_fn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new linkhash table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>initial table size. The table is automatically resized although this incurs a performance penalty. </td></tr>
    <tr><td class="paramname">free_fn</td><td>callback function used to free memory for entries when lh_table_free or lh_table_delete is called. If NULL is provided, then memory for keys and values must be freed by the caller. </td></tr>
    <tr><td class="paramname">hash_fn</td><td>function used to hash keys. 2 standard ones are defined: lh_ptr_hash and lh_char_hash for hashing pointer values and C strings respectively. </td></tr>
    <tr><td class="paramname">equal_fn</td><td>comparison function to compare keys. 2 standard ones defined: lh_ptr_hash and lh_char_hash for comparing pointer values and C strings respectively. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the new linkhash table is returned. On error, a null pointer is returned. </dd></dl>

</div>
</div>
<a id="a30c8414e31aeee7669acc938116d933f" name="a30c8414e31aeee7669acc938116d933f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c8414e31aeee7669acc938116d933f">&#9670;&#160;</a></span>lh_table_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lh_table_resize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlh__table.html">lh_table</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>new_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resizes the specified table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Pointer to table to resize. </td></tr>
    <tr><td class="paramname">new_size</td><td>New table size. Must be positive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, <code>0</code> is returned. On error, a negative value is returned. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for json-c by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
